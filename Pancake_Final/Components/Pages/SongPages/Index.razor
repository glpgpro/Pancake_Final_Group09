@page "/Home"
@using Microsoft.EntityFrameworkCore
@using Pancake_Final.Domain
@using Pancake_Final.Data
@implements IAsyncDisposable
@inject IDbContextFactory<Pancake_Final.Data.Pancake_FinalContext> DbFactory
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>Home</PageTitle>

<header>
    <img class="HeaderLogo" src="/images/pancakeLogo.png" alt="Logo"> Pancake
</header>

<div class="SearchBarDiv">
    <input type="text"
           id="SearchBar"
           placeholder="Enter a song"
           @oninput="SearchSongs"></input>
</div>

<div class="SongContainer">
    <table class="song-table">
        <thead>
            <tr>
                <th>#</th>
                <th>Title</th>
                <th>Artist</th>
                <th>Date Added</th>
                <th>Duration</th>
                <th>Play</th>
            </tr>
        </thead>
        <p>Total Songs: @Songs.Count</p>
        @if (PaginatedSongs != null && PaginatedSongs.Any())
        {
            @foreach (var song in PaginatedSongs)
            {
                <tr>
                    <td>@(FilteredSongs.IndexOf(song) + 1)</td>
                    <td>@song.Name</td>
                    <td>@song.ArtistId</td>
                    <td>@DateTime.Now.ToShortDateString()</td>
                    <td>@FormatDuration(song.Duration)</td>
                    <td>
                        <button class="btn btn-success btn-sm" @onclick="() => PlaySong(song.FilePath)">Play</button>
                    </td>
                    <td>
                        <button class="btn btn-sm @(song.LikedS == "Liked" ? "btn-success" : "btn-danger")"
                                 @onclick="() => ToggleLike(song)">
                            @(song.LikedS == "Liked" ? "Unlike" : "Like")
                        </button>
                    </td>
                </tr>
            }
        }
        else
        {
            <tr>
                <td colspan="6">No songs found.</td>
            </tr>
        }
    </table>
</div>

<div class="PaginationControls">
    <button @onclick="PreviousPage" class="btn btn-secondary" disabled="@IsFirstPage">Previous</button>
    <span>Page @CurrentPage of @TotalPages</span>
    <button @onclick="NextPage" class="btn btn-secondary" disabled="@IsLastPage">Next</button>
</div>

<div class="AudioPlayback">
    <audio id="audioPlayer" controls style="width: 100%;"></audio>
</div>
<!-- Link for JavaScript file -->
<script src="/Js/AudioPlayer.js"></script>

@code {
    private Pancake_FinalContext context = default!;
    private List<Song> Songs = new(); // List of all songs
    private List<Song> FilteredSongs = new(); // Filtered songs for search
    private List<Song> PaginatedSongs = new(); // Songs displayed on the current page

    private int CurrentPage = 1; // Current page number
    private int PageSize = 5; // Number of songs per page
    private int TotalPages => (int)Math.Ceiling((double)FilteredSongs.Count / PageSize); // Total pages
    private bool IsFirstPage => CurrentPage == 1;
    private bool IsLastPage => CurrentPage == TotalPages;

    private bool isLoading = false;

    protected override async Task OnInitializedAsync()
    {
        isLoading = true;
        try
        {
            context = await DbFactory.CreateDbContextAsync();
            Songs = await context.Song.ToListAsync();
            FilteredSongs = Songs;  // Initially no filtering
            UpdatePagination();
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync() => await context.DisposeAsync();

    private async Task ToggleLike(Song song)
    {
        try
        {
            // Toggle the LikedS value
            song.LikedS = song.LikedS == "Liked" ? "NotLiked" : "Liked";

            // Save the change to the database
            context.Song.Update(song);
            await context.SaveChangesAsync();

            // Optionally refresh UI
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating song: {ex.Message}");
        }
    }

    private void SearchSongs(ChangeEventArgs e)
    {
        var searchTerm = e.Value?.ToString()?.ToLower();
        
        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            // If search is cleared, reset the filtered songs to all songs
            FilteredSongs = new List<Song>(Songs);
        }
        else
        {
            // Filter songs based on the search term (case-insensitive search for song name)
            FilteredSongs = Songs
                .Where(song => song.Name.ToLower().Contains(searchTerm))
                .ToList();
        }

        // After filtering, reset to the first page and update pagination
        CurrentPage = 1;
        UpdatePagination();
    }

    private void NextPage()
    {
        if (!IsLastPage)
        {
            CurrentPage++;
            UpdatePagination();
            StateHasChanged();
        }
    }

    private void PreviousPage()
    {
        if (!IsFirstPage)
        {
            CurrentPage--;
            UpdatePagination();
            StateHasChanged();
        }
    }

    private void UpdatePagination()
    {
        PaginatedSongs = FilteredSongs
            .Skip((CurrentPage - 1) * PageSize) // Skip songs from previous pages
            .Take(PageSize) // Take only the songs for the current page
            .ToList();
    }
    private string FormatDuration(TimeSpan duration)
    {
        int minutes = (int)duration.TotalMinutes;
        double seconds = Math.Round(duration.Seconds + duration.Milliseconds / 1000.0, 2);
        return $"{minutes}:{seconds:00.00}";
    }

    private async Task PlaySong(string filePath)
    {
        if (string.IsNullOrEmpty(filePath))
        {
            Console.WriteLine("Error: FilePath is empty!");
            return;
        }

        Console.WriteLine($"Attempting to play: {filePath}");
        await JSRuntime.InvokeVoidAsync("playAudio", filePath);

        try
        {
            // Find the song based on the filePath
            var song = await context.Song.FirstOrDefaultAsync(s => s.FilePath == filePath);
            if (song == null)
            {
                Console.WriteLine("Error: Song not found in the database.");
                return;
            }

            // Save the song in the listening history
            var history = new ListeningHistory
            {
                UserId = 1, // Replace with actual logged-in user ID
                SongId = song.Id,
                Name = song.Name,
                DatePlayed = DateTime.UtcNow
            };

            await context.ListeningHistory.AddAsync(history);
            await context.SaveChangesAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving listening history: {ex.Message}");
        }
    }
}
